/*********************************** 
minimalect 
Minimal select replacement for jQuery 

jQuery 1.7+ required. 
Developed by @groenroos 
http://www.groenroos.fi 

Github: git://github.com/groenroos/minimalect.git w 

Licensed under the MIT license.

************************************/
module.exports=function(a){!function(a,b,c,d){
// The actual plugin constructor
function e(b,c){this.element=a(b),this.options=a.extend({},g,c),this._defaults=g,this._name=f,this.label=a('[for="'+this.element.attr("id")+'"]').attr("for","minict_"+this.element.attr("id")),this._init()}var f="minimalect",g={
// settings
theme:"",// name of the theme used
reset:!1,transition:"fade",transition_time:150,remove_empty_option:!0,searchable:!0,// whether or not the combobox functionality is enabled
ajax:null,// URL to an external resource
debug:!1,// whether to be verbose in the console
live:!0,// whether to automatically detect changes
listen_to_select:!1,// listens for changes to the associated select element
// messages
placeholder:"Select a choice",// default placeholder when nothing is selected
empty:"No results match your keyword.",// error message when nothing matches the filter search term
error_message:"There was a problem with the request.",// error message when the AJAX call fails
// classes
class_container:"minict_wrapper",// wrapper div for the element
class_group:"minict_group",// list item for an optgroup
class_empty:"minict_empty",// "No results" message
class_active:"active",// applied to wrapper when the dropdown is displayed
class_disabled:"disabled",// applied to list elements that are disabled
class_selected:"selected",// the currently selected item in the dropdown
class_hidden:"hidden",// an item that doesn't match the filter search term
class_highlighted:"highlighted",// item highlighted by keyboard navigation
class_first:"minict_first",// first visible element
class_last:"minict_last",// last visible element
class_reset:"minict_reset",// reset link
// callbacks
beforeinit:function(){},// called before Minimalect is initialized
afterinit:function(){},// called right after Minimalect is initialized
onchange:function(){},// called whenever the user changes the selected value
onopen:function(){},// called when the dropdown is displayed
onclose:function(){},// called when the dropdown is hidden
onfilter:function(){}};e.prototype={
// INITIALIZATION
_init:function(){
// before init callback
this.options.beforeinit();
// PREPWORK
var d=this.options,e=this;
// poll the original for changes
if(this.initVal=e.element.val(),d.ajax&&(d.live=!1),
// create the wrapper
this.wrapper=a('<div class="'+d.class_container+'"></div>'),
// hide the original select and add the wrapper
this.element.hide().after(this.wrapper),
// apply the current theme to the wrapper
d.theme&&this.wrapper.addClass(d.theme),
// reflect disabled status
this.element.prop("disabled")&&this.wrapper.addClass(d.class_disabled),
// create and add the input
this.input=a("<span "+(d.searchable?'contenteditable="true"':"")+' data-placeholder="'+(this.element.find("option[selected]").text()||this.element.attr("placeholder")||null!=d.placeholder?d.placeholder:this.element.find("option:first").text())+'" '+(this.element.is("[tabindex]")?"tabindex="+this.element.attr("tabindex"):"")+">"+(this.element.find("option[selected]").html()||"")+"</span>").appendTo(this.wrapper),
// add the reset link, if it's wanted
d.reset&&(this.reset=a('<a href="#" class="'+d.class_reset+'">&#215;</a>').appendTo(this.wrapper)),
// parse the select itself, and create the dropdown markup
this.ul=a("<ul>"+this._parseSelect()+'<li class="'+d.class_empty+'">'+d.empty+"</li></ul>").appendTo(this.wrapper),this.items=this.wrapper.find("li"),
// if it's preselected, select the option itself as well
this.element.find("option[selected]").length&&(this._showResetLink(),this.items.filter('[data-value="'+this.element.find("option[selected]").val()+'"]').addClass(d.class_selected)),
// BIND EVENTS
// hide dropdown when you click elsewhere
a(c).on("click",function(){e._hideChoices(e.wrapper)}),
// hide dropdown when moving focus outside it
a("*").not(this.wrapper).not(this.wrapper.find("*")).on("focus",function(){e._hideChoices(e.wrapper)}),
// toggle dropdown when you click on the dropdown itself
this.wrapper.on("click",function(a){a.stopPropagation(),
// only close the dropdown when it's not disabled and not multiselect
e.element.prop("multiple")||e.element.prop("disabled")||e._toggleChoices()}),
// toggle dropdown when you click on the associated label, if present
this.label.on("click",function(a){a.stopPropagation(),e.input.trigger("focus")}),
// select choice when you click on it
this.wrapper.on("click","li:not(."+d.class_group+", ."+d.class_empty+", ."+d.class_disabled+")",function(){e._selectChoice(a(this))}),
// stop the dropdown from closing when you click on a group or empty placeholder
this.wrapper.on("click","li."+d.class_group+", li."+d.class_empty+", li."+d.class_disabled,function(a){a.stopPropagation(),e.input.focus()}),
// if the original is focused or blurred manually, mimic it
// also handle the custom update event
this.element.on("focus",function(){e.element.blur(),e._showChoices()}).on("blur",e._hideChoices).on("update",e.update),
// bind reset only if it's there
d.reset&&this.wrapper.on("click","a."+d.class_reset,function(a){return a.stopPropagation(),e._resetChoice(),!1}),
// key bindings for the input element
this.input.on("focus click",function(a){a.stopPropagation(),e.element.prop("disabled")?e.input.blur():e._showChoices()}).on("keydown",function(a){
// keyboard navigation
switch(a.keyCode){
// up
case 38:a.preventDefault(),e._navigateChoices("up");break;
// down
case 40:a.preventDefault(),e._navigateChoices("down");break;
// enter
case 13:
// tab
case 9:
// select the highlighted choice
e.items.filter("."+d.class_highlighted).length?e._selectChoice(e.items.filter("."+d.class_highlighted)):e.input.text()&&e._selectChoice(e.items.not("."+d.class_group+", ."+d.class_empty).filter(":visible").first()),13===a.keyCode&&(a.preventDefault(),e._hideChoices(e.wrapper));break;
// escape
case 27:a.preventDefault(),
// close the select and don't change the value
e._hideChoices(e.wrapper)}}).on("keyup",function(b){
// if we're not navigating, filter
-1===a.inArray(b.keyCode,[38,40,13,9,27])&&e._filterChoices()}),
// if mutation observing is supported
b.MutationObserver&&(
// observe the original for DOM changes so they can be reflected
this.observer=new MutationObserver(function(a){
// if there were changes...
a.length>0&&(
// ...reparse the select
e.ul.html(e._parseSelect()+'<li class="'+d.class_empty+'">'+d.empty+"</li>"),e.items=e.wrapper.find("li"),e.options.debug&&console.log("Minimalect detected a DOM change for ",e.element))}),this.observer.observe(e.element[0],{childList:!0})),d.live){
// set cache to the original value
var f=this.element.val();
// set a tight interval to check for the original
setInterval(function(){
// if we're out of date
f!=e.element.val()&&null!=e.element.val()&&""!=e.element.val()?(f=e.element.val(),"array"==typeof f?f.each(function(a,b){e._selectChoice(e.wrapper.find("li[data-value='"+b+"']"))}):e._selectChoice(e.wrapper.find("li[data-value='"+f+"']"))):null!=e.element.val()&&""!=e.element.val()||(f=e.element.val(),e.items.removeClass(e.options.class_selected),e.input.text("").attr("data-placeholder",e.options.placeholder)),
// let's also check for disabled
e.element.prop("disabled")?e.wrapper.addClass(d.class_disabled):e.wrapper.removeClass(d.class_disabled)},100)}if(d.listen_to_select){
// set cache to the original value
var f=this.element.val(),g=function(){
// if we're out of date
f!=e.element.val()&&null!=e.element.val()&&""!=e.element.val()?(f=e.element.val(),"array"==typeof f?f.each(function(a,b){e._selectChoice(e.wrapper.find("li[data-value='"+b+"']"))}):e._selectChoice(e.wrapper.find("li[data-value='"+f+"']"))):null!=e.element.val()&&""!=e.element.val()||(f=e.element.val(),e.items.removeClass(e.options.class_selected),e.input.text("").attr("data-placeholder",e.options.placeholder)),
// let's also check for disabled
e.element.prop("disabled")?e.wrapper.addClass(d.class_disabled):e.wrapper.removeClass(d.class_disabled)};e.element.on("change",g)}
// after init callback
d.afterinit()},
// PRIVATE METHODS
// navigate with a keyboard
// dr - direction we're going, either "up" or "down"
_navigateChoices:function(a){var// jQuery reference for the wrapper
b=(this.wrapper,this.options),// options object
c=this.items,d="."+b.class_hidden+", ."+b.class_empty+", ."+b.class_group;if(!c.filter("."+b.class_highlighted).length)// if nothing is selected, select the first or last
return"up"===a?c.not(d).last().addClass(b.class_highlighted):"down"===a&&c.not(d).first().addClass(b.class_highlighted),!1;
// ...and figure out the next one
if(// if something is selected...
// ...remove current selection...
cur=c.filter("."+b.class_highlighted),cur.removeClass(b.class_highlighted),"up"===a)if(c.not(d).first()[0]!=cur[0]){// if we're not at the first
cur.prevAll("li").not(d).first().addClass(b.class_highlighted);// highlight the prev
// make sure it's visible in a scrollable list
var e=c.filter("."+b.class_highlighted).offset().top-this.ul.offset().top+this.ul.scrollTop();this.ul.scrollTop()>e&&this.ul.scrollTop(e)}else// if we are at the first
c.not(d).last().addClass(b.class_highlighted),// highlight the last
// make sure it's visible in a scrollable list
this.ul.scrollTop(this.ul.height());else if("down"===a)if(c.not(d).last()[0]!=cur[0]){// if we're not at the last
cur.nextAll("li").not(d).first().addClass(b.class_highlighted);// highlight the next
// make sure it's visible in a scrollable list
var f=this.ul.height(),g=c.filter("."+b.class_highlighted).offset().top-this.ul.offset().top+c.filter("."+b.class_highlighted).outerHeight();g>f&&this.ul.scrollTop(this.ul.scrollTop()+g-f)}else// if we are at the last
c.not(d).first().addClass(b.class_highlighted),// highlight the first
// make sure it's visible in a scrollable list
this.ul.scrollTop(0)},
// parse the entire select and return the new markup
_parseSelect:function(){var a="";return a=this._parseElements(this.element.html())},
// turn option elements and optgroup elements into li elements
// the runs recursively on the child elements of each optgroup
// elhtml - HTML containing the options and/or optgroups
_parseElements:function(b){var c=this,d="";
// spit it out
// go through each option
return a(a.trim(b)).filter("option, optgroup").each(function(){var b=a(this);if(b.is("optgroup"))d+='<li class="'+c.options.class_group+'">'+a(this).attr("label")+"</li>",d+=c._parseElements(b.html());else{if(""===b.attr("value")&&c.options.remove_empty_option)return;
// create an li with a data attribute containing its value
d+='<li data-value="'+b.val().replace(/"/g,"&quot;")+'" class="'+(b.attr("class")||"")+(b.prop("disabled")?" "+c.options.class_disabled:"")+'">'+b.text()+"</li>"}}),d},
// toggle the visibility of the dropdown
_toggleChoices:function(){this.wrapper.hasClass(this.options.class_active)?this._hideChoices(this.wrapper):this._showChoices()},
// show the dropdown
// cb - callback before the animation plays
_showChoices:function(b){var c=this,d=this.wrapper,// jQuery reference for the wrapper
e=this.options;// options object
if(d.hasClass(e.class_active))
// internal callback
"function"==typeof b&&b.call();else{switch(
// keep the first and last classes up to date
this._updateFirstLast(!1),
// close all other open minimalects
a("."+e.class_container).each(function(){//todo this doesn't work if the container classes are different
a(this)[0]!==d[0]&&c._hideChoices(a(this))}),
// internal callback
"function"==typeof b&&b.call(),
// add the active class
d.addClass(e.class_active),e.transition){case"fade":this.ul.fadeIn(e.transition_time);break;default:this.ul.show()}
// make the input editable
this.input.text("").focus(),
// hide the reset link
this._hideResetLink(),
// callback
this.options.onopen()}},_resetDropdown:function(a){var b=this.options;// options object
// reset the filtered elements
this.items.removeClass(b.class_hidden),
// hide the empty error message
this.wrapper.find("."+b.class_empty).hide(),
// reset keyboard navigation
this.items.filter("."+b.class_highlighted).removeClass(b.class_highlighted),
// internal callback
"function"==typeof a&&a.call()},
// hide the dropdown
// wr - jQuery reference for the wrapper
// cb - callback for after the animation has played
_hideChoices:function(a,b){var c=this.options,// options object
d=c.transition_time,// timeout for the transition to finish
e=this;if(a.hasClass(c.class_active)){switch(
// remove the active class and fade out
a.removeClass(c.class_active),c.transition){case"fade":a.children("ul").fadeOut(c.transition_time);break;default:a.children("ul").hide(),d=0}
// set a timeout for clearing the field, so there's no flickering
setTimeout(function(){
// reset filters
e._resetDropdown(b),
// blur the input
e.input.blur(),
// reset it
e.input.attr("data-placeholder")!=c.placeholder?
// if we have a previously selected value, restore that
e.input.text(e.input.attr("data-placeholder")):e.items.filter("."+c.class_selected).length||
// if we have no selection, empty it to show placeholder
e.input.text("")},d),
// show the reset link
e._showResetLink(),
// callback
c.onclose()}else
// internal callback
"function"==typeof b&&b.call()},
// filter choices based on user input
_filterChoices:function(){var b=this.wrapper,// jQuery reference for the wrapper
c=this.options,// options object
d=this;if(c.ajax)
// if we're searching from ajax
a.post(c.ajax,{q:this.input.text()}).success(function(e){if(
// we got a response
c.debug&&console.log("Minimalect received ",e," for query '"+d.input.text()+"' in ",d.element),e.length){
// if we have results
var f="";a.each(e,function(a,b){
// parse each data point to an option in the original
f+='<option value="'+b.value+'">'+b.name+"</option>"}),
// populate original element
d.element.html(f),
// parse and display it
d.ul.html(d._parseSelect()+'<li class="'+c.class_empty+'">'+c.empty+"</li>"),b.find("."+c.class_empty).hide(),
// refresh internal cache
d.items=b.find("li"),
// callback, results found
d.options.onfilter(!0)}else
// show a "no results" placeholder if there's nothing to show
d.ul.html('<li class="'+c.class_empty+'">'+c.empty+"</li>"),b.find("."+c.class_empty).show(),
// tell the console if debug mode is on
c.debug&&console.log("Minimalect didn't find any results for '"+d.input.text()+"' from ",d.element),
// callback, no results found
d.options.onfilter(!1)}).error(function(a){
// show feedback for the user
b.find("."+c.class_empty).text(c.error_message),b.find("li").not("."+c.class_empty).addClass(c.class_hidden),b.find("."+c.class_empty).show(),
// tell the console if debug mode is on
c.debug&&console.error("Minimalect's AJAX query failed for ",d.element," - came back with ",a)});else{
// traditional filtering
// get the filter value, escape regex chars (thanks Andrew Clover!)
var e=this.input.text().replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");
// reset keyboard navigation
this.items.filter("."+c.class_highlighted).removeClass(c.class_highlighted),
// filter through each option
this.items.not(c.class_group).each(function(){
// if there's no match (or if it's disabled), hide it. otherwise, unhide it
a(this).text().search(new RegExp(e,"i"))<0||a(this).hasClass(c.class_disabled)?a(this).addClass(c.class_hidden):a(this).removeClass(c.class_hidden)}),
// make sure optgroups with no choices are hidden
// sort of a kludge since we have no hierarchy
this.items.filter("."+c.class_group).removeClass(c.class_hidden).each(function(){nextlis=a(this).nextAll("li").not("."+c.class_hidden+", ."+c.class_empty),!nextlis.first().hasClass(c.class_group)&&nextlis.length||a(this).addClass(c.class_hidden)}),
// show a "no results" placeholder if there's nothing to show
b.find("."+c.class_empty).hide(),this.items.not("."+c.class_hidden+", ."+c.class_empty).length?
// callback, results found
this.options.onfilter(!0):(b.find("."+c.class_empty).show(),
// tell the console if debug mode is on
c.debug&&console.log("Minimalect didn't find any results for '"+this.input.text()+"' from ",this.element),
// callback, no results found
this.options.onfilter(!1)),
// keep the first and last classes up to date
this._updateFirstLast(!0)}},
// select the choice defined
// ch - jQuery reference for the li element the user has chosen
_selectChoice:function(b){var c=this.element,// jQuery reference for the original select element
d=this.options,// options object
e=[],f=[];
// if it's disabled, au revoir
// if it's disabled, au revoir
// apply the selected class
// show it up in the input
// if the selected choice is different
// update the original select element
// call original select change event
// callback
return b.hasClass(this.options.class_disabled)?!1:(d.live||(this.items=this.wrapper.find("li")),this.element.prop("multiple")||this.items.removeClass(d.class_selected),b.addClass(d.class_selected),this.items.filter("."+d.class_selected).each(function(){e.push(a(this).data("value")),f.push(a(this).text())}),this.input.text(f.join(", ")).attr("data-placeholder",f.join(", ")),c.val()==b.data("value")&&c.val()==e||(c.val(e),c.trigger("change")),this._showResetLink(),void this.options.onchange.call(this,b.data("value"),b.text()))},
// clear the select
_resetChoice:function(){this.element.val("").trigger("change"),this._hideResetLink()},
// show the reset link if options.reset is true
_showResetLink:function(){(this.input.text().length>0||this.ul.find("li."+this.options.class_selected).length>0)&&this.options.reset&&this.reset.show()},
// hide the reset link if options.reset is true
_hideResetLink:function(){this.options.reset&&this.reset.hide()},
// keep the first and last classes up-to-date
// vi - whether we want to count visibility or not
_updateFirstLast:function(a){var b=this.wrapper,// jQuery reference for the wrapper
c=this.options;// options object
b.find("."+c.class_first+", ."+c.class_last).removeClass(c.class_first+" "+c.class_last),a?(this.items.filter(":visible").first().addClass(c.class_first),this.items.filter(":visible").last().addClass(c.class_last)):(this.items.first().addClass(c.class_first),this.items.not("."+c.class_empty).last().addClass(c.class_last))},
// PUBLIC METHODS
// uninit Minimalect
destroy:function(){
// remove (and automatically unbind) all Minimalect stuff
this.wrapper.remove(),
// display and unhook the original
this.element.off("change focus blur").show(),
// stop listening for changes
b.MutationObserver&&this.observer.disconnect(),
// if debug mode is on, let them know upstairs
this.options.debug&&console.log("Minimalect destroyed for ",this.element)},
// update Minimalect's choice from the original select
update:function(){
// reparse the select
this.ul.html(this._parseSelect()+'<li class="'+this.options.class_empty+'">'+this.options.empty+"</li>")}},a.fn[f]=function(b,c){return this.each(function(){a.isFunction(e.prototype[b])&&"_"!=b.charAt(0)?1==arguments.length?a.data(this,"plugin_"+f)[b]():a.data(this,"plugin_"+f)[b](c):a.data(this,"plugin_"+f)||a.data(this,"plugin_"+f,new e(this,b))})}}(a,window,document)};